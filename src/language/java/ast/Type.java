package language.java.ast;

/* 
 * Copyright (C) 2000  Andrew Violette
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA 
 *
 * Andrew Violette 
 * aviolette@acm.org
 *
 */

import java.util.*;
import tree.*;

/**
 * A <code>Type</code> node represents a type bound to a variable,
 * method, name, identifier, or literal.  A type can have both a name
 * and a dimension.  If the dimension is 0 the type is not an array,
 * otherwise it is.  There are several "standard" types which include
 * all the primitive types, String, and NullObject.  Instances of
 * these types can be generated by passing any of the ST_* constants
 * to the Type constructor.  
 */

public final class Type
extends Node
{
    private int m_dimension;
    private String m_name;

    private static java.util.Map s_attributes;

    protected Map attributeMap()
    {
	if(s_attributes == null)
	{
	    s_attributes = new HashMap();
	    initializeAttributeMap(s_attributes);
	}
	return s_attributes;
    }

    protected void initializeAttributeMap(Map map)
    {
	map.put("Dimension", new TreeNode.AttributeMetaData(Integer.TYPE, false, 
							    new Integer(0), "The type's dimension.  A value of zero means that it is not an array."));
	map.put("Name", new TreeNode.AttributeMetaData(String.class, false, null, "The type's name."));
    }


    public int getCollectionCount()
    {
	return 0;
    }
    
    public static final String LABEL = "type";
 
    /**
     * A "void" type.
     */
    public static final String ST_VOID = "void";
    /**
     * A char type.
     */
    public static final String ST_CHAR = "char";
    /**
     * A NullObject type.
     */
    public static final String ST_NULL = "null";
    /**
     * An int.
     */
    public static final String ST_INT = "int";
    /**
     * A float
     */
    public static final String ST_FLOAT = "float";
    /**
     * A double
     */
    public static final String ST_DOUBLE = "double";
    /**
     * A String object.
     */
    public static final String ST_STRING = "String";

    protected String getPrivateLabel()
    {
	return LABEL;
    }

    /**
     * Constructs a type with the specified name, and a dimension of
     * zero.  
     */

    public Type(String name)
    {
	this(name, 0);
    }

    /**
     * Constructs an empty type.
     */

    public Type()
    {
    }

    /**
     * Cosntructs a type with the specified name and dimension.
     */

    public Type(String name, int dimension)
    {
	m_name = name;
	m_dimension = dimension;
    }

    /**
     * Returns true if o matches the specified type.  If o is a
     * <code>Type</code> object, then it will check both the name and
     * dimension.  If o is a String, it will return true if the name
     * of the class and the specified String match.  Otherwise it will
     * return false.  
     */

    public boolean equals(Object o)
    {
	if(o == this) return true;

	if(o instanceof Type)
	{
	    Type t = (Type)o;
	    return m_name.equals(t.m_name) && (m_dimension == t.m_dimension);
	}
	else if(o instanceof String)
	{
	    return m_name.equals((String)o);
	}
	return false;
    }

    public void accept(ASTTraverser visitor)
    {
	visitor.visit(this);
    }

    public String toString()
    {
	java.util.Vector v = getStandardDescriptiveElements();
	v.addElement(getName());
	v.addElement(new Integer(m_dimension));
	return createDescriptiveTuple(LABEL, v.iterator());
    }

    /**
     * Sets the type name.
     */

    public void setName(String name)
    {
	m_name = name;
    }

    /**
     * Returns the type name.
     */

    public String getName()
    {
	return m_name;
    }

    /**
     * Sets the type dimension.
     */

    public void setDimension(int dimension)
    {
	m_dimension = dimension;
    }

    /**
     * Returns the type dimension.
     */

    public int getDimension()
    {
	return m_dimension;
    }

    public void addChild(TreeNode n, int col, int pos)
    {
	debug.Debug.assert(false);
    }
    public boolean removeChild(TreeNode n)
    {
	return false;
    }

    public TreeNode childAt(int col, int pos)
    {
	return null;
    }
    public java.util.Iterator children(int col)
    {
	debug.Debug.assert(false);
	return null;
    }
    
    public int childCount(int col)
    {
	debug.Debug.assert(false);
	return 0;
    }
}
